<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>GameCre8 — Galaxy Blaster (No-CDN)</title>
<meta name="description" content="Single-file polished space shooter. No external scripts. Desktop + iPhone.">
<style>
  :root{--fg:#eaf2ff;--muted:#a9b5d6;--bg:#0b0f1a;--panel:#0f1530;--line:#263157;--accent:#21d0ff}
  *{box-sizing:border-box} html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:980px;margin:0 auto;padding:20px 14px}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:16px;padding:16px;margin:12px 0}
  .heroGlow{box-shadow:0 12px 48px rgba(33,208,255,.18), inset 0 0 30px rgba(33,208,255,.06);border:1px solid #1c2a58}
  #gameBox{position:relative;border:1px solid var(--line);border-radius:16px;overflow:hidden;background:#0b0f1a;min-height:540px}
  #hud{position:absolute;top:8px;left:8px;display:flex;gap:6px;z-index:3}
  .pill{padding:6px 10px;border-radius:999px;background:rgba(9,13,28,.6);border:1px solid var(--line);backdrop-filter:blur(6px);font-size:14px}
  #overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(3,6,16,.65);backdrop-filter:blur(2px);z-index:4}
  .overlayCard{background:#0e1431;border:1px solid #253062;border-radius:14px;max-width:460px;padding:18px;text-align:center}
  .overlayCard h2{margin:0 0 8px}
  .btn{appearance:none;border:1px solid var(--line);background:#1a2a66;color:#eaf2ff;border-radius:10px;padding:10px 14px;cursor:pointer}
  .tips{position:absolute;bottom:8px;left:8px;opacity:.85;font-size:12px;color:#cfe3ff;background:rgba(0,0,0,.35);padding:6px 8px;border-radius:8px;z-index:2}
  #err{display:none;margin-top:8px;background:#2a0f18;border:1px solid #7a2036;color:#ffd6df;padding:10px;border-radius:10px;white-space:pre-wrap}
</style>
</head>
<body>
<div class="wrap">
  <div class="card heroGlow">
    <h1 style="margin:0 0 6px">GameCre8 — Galaxy Blaster <span style="opacity:.65">Elite</span></h1>
    <p style="margin:0;color:#a9b5d6">Polished single-file build (no CDN). If anything fails, error will show below.</p>
    <div id="err"></div>
  </div>
  <div class="card">
    <div id="gameBox">
      <canvas id="game" width="960" height="540" style="display:block;width:100%;height:auto"></canvas>
      <div id="hud">
        <div class="pill">Score: <b id="scoreV">0</b></div>
        <div class="pill">Wave: <b id="waveV">1</b>/5</div>
        <div class="pill">Lives: <b id="livesV">3</b></div>
        <div class="pill">Power: <b id="powerV">—</b></div>
      </div>
      <div id="overlay">
        <div class="overlayCard">
          <h2 id="ovTitle">Game Over</h2>
          <div>You reached wave <b id="ovWave">1</b> with score <b id="ovScore">0</b>.</div>
          <div style="margin-top:12px"><button id="retryBtn" class="btn">Play Again</button></div>
        </div>
      </div>
      <div class="tips">Mobile: drag to move, tap to shoot · Desktop: WASD/Arrows + Space</div>
    </div>
  </div>
</div>

<script>
(function(){
  const elErr = document.getElementById('err');
  function showErr(m){ elErr.style.display='block'; elErr.textContent = m; }

  // ----------- Minimal engine (canvas) — no dependencies -----------
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d',{alpha:false});
  const W = ()=>cvs.width, H=()=>cvs.height;
  let tPrev=0, rafId=0, running=true, timeScale=1;

  const mobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const key = {left:false,right:false,up:false,down:false,space:false};
  window.addEventListener('keydown',e=>{
    if(e.code==='ArrowLeft'||e.code==='KeyA') key.left=true;
    if(e.code==='ArrowRight'||e.code==='KeyD') key.right=true;
    if(e.code==='ArrowUp'||e.code==='KeyW') key.up=true;
    if(e.code==='ArrowDown'||e.code==='KeyS') key.down=true;
    if(e.code==='Space') key.space=true;
  });
  window.addEventListener('keyup',e=>{
    if(e.code==='ArrowLeft'||e.code==='KeyA') key.left=false;
    if(e.code==='ArrowRight'||e.code==='KeyD') key.right=false;
    if(e.code==='ArrowUp'||e.code==='KeyW') key.up=false;
    if(e.code==='ArrowDown'||e.code==='KeyS') key.down=false;
    if(e.code==='Space') key.space=false;
  });

  let touchMove=null, touchFire=false;
  if (mobile){
    cvs.addEventListener('touchstart', (e)=>{ const p=e.touches[0]; touchMove={x:p.clientX,y:p.clientY}; touchFire=true; }, {passive:true});
    cvs.addEventListener('touchmove',  (e)=>{ if(!touchMove) return; const p=e.touches[0]; player.x += (p.clientX-touchMove.x)*(960/cvs.clientWidth); player.y += (p.clientY-touchMove.y)*(540/cvs.clientHeight); touchMove={x:p.clientX,y:p.clientY}; clampPlayer(); }, {passive:true});
    cvs.addEventListener('touchend',   ()=>{ touchMove=null; touchFire=false; }, {passive:true});
  } else {
    cvs.addEventListener('mousedown', ()=>{ touchFire=true; });
    cvs.addEventListener('mouseup',   ()=>{ touchFire=false; });
  }

  // ---------- SFX via WebAudio (tiny) ----------
  const AC = window.AudioContext||window.webkitAudioContext; const actx = AC ? new AC() : null;
  let noiseBuf=null; if(actx){ const len=44100*0.22, buf=actx.createBuffer(1,len,44100), d=buf.getChannelData(0); for(let i=0;i<len;i++) d[i]=(Math.random()*2-1)*(1-i/len); noiseBuf=buf; }
  let soundOn=true; function envTone(f0,f1,ms,gain,type='sawtooth'){ if(!actx||!soundOn) return; const o=actx.createOscillator(), g=actx.createGain(), now=actx.currentTime; o.type=type; o.frequency.value=f0; o.frequency.setValueAtTime(f0,now); o.frequency.exponentialRampToValueAtTime(Math.max(40,f1), now+ms/1000); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(gain,now+0.01); g.gain.exponentialRampToValueAtTime(0.0001,now+ms/1000); o.connect(g).connect(actx.destination); o.start(now); o.stop(now+ms/1000+0.02); }
  function sfxLaser(){ envTone(950,1400,90,0.12,'square'); }
  function sfxBoom(big=true){ if(!actx||!soundOn) return; envTone(big?240:320,80,big?260:180,big?0.27:0.18,'sawtooth'); if(noiseBuf){ const n=actx.createBufferSource(); const g=actx.createGain(); g.gain.value=0.16; n.buffer=noiseBuf; n.connect(g).connect(actx.destination); n.start(); } }

  // ---------- Game state ----------
  const hud = {score:0,wave:1,lives:3,power:'—', rapidT:0, spreadT:0, shieldT:0};
  const scoreV=document.getElementById('scoreV'), waveV=document.getElementById('waveV'),
        livesV=document.getElementById('livesV'), powerV=document.getElementById('powerV');
  function setHud(){ scoreV.textContent=hud.score; waveV.textContent=hud.wave+'/5'; livesV.textContent=hud.lives; powerV.textContent=hud.power; }
  setHud();

  const player = {x:W()*0.5,y:H()*0.78,vx:0,vy:0, speed:1100, r:22, alive:true};
  const bullets=[], enemies=[], rocks=[], enemyBullets=[], sparks=[], powerups=[];
  let autofire=0, trailT=0;

  function clampPlayer(){
    player.x = Math.max(26, Math.min(W()-26, player.x));
    player.y = Math.max(26, Math.min(H()-26, player.y));
  }

  // ---------- Utility ----------
  function rnd(a,b){ return a + Math.random()*(b-a); }
  function hit(a,b,dist){ const dx=a.x-b.x, dy=a.y-b.y; return (dx*dx+dy*dy) <= dist*dist; }
  function addScore(v){ hud.score += v; setHud(); }

  // ---------- Spawns ----------
  function spawnWave(){
    const hard=Math.min(1+(hud.wave-1)*0.2,2.2);
    // fighters
    for(let i=0;i<Math.round(6*hard);i++){
      enemies.push({x:rnd(40,W()-40), y:rnd(-500,-30), vx:0, vy:rnd(120,180)+hud.wave*8, hp:2+Math.floor(hud.wave/3), ai:'zig', tilt:Math.random()<.5?-1:1, fireT:rnd(0.5,1.2), boss:false});
    }
    // interceptors
    for(let i=0;i<Math.round(3*hard);i++){
      enemies.push({x:rnd(60,W()-60), y:rnd(-560,-40), vx:0, vy:rnd(140,200)+hud.wave*6, hp:2, ai:'sine', phase:Math.random()*Math.PI*2, amp:rnd(40,80), fireT:rnd(0.8,1.4), boss:false});
    }
    // tanks
    for(let i=0;i<Math.max(0,Math.round(hud.wave-2));i++){
      enemies.push({x:rnd(60,W()-60), y:rnd(-560,-40), vx:0, vy:rnd(90,140)+hud.wave*4, hp:5+Math.floor(hud.wave/2), ai:'straight', fireT:rnd(1.0,1.8), boss:false});
    }
    // rocks
    for(let i=0;i<Math.round(4*hard);i++){
      rocks.push({x:rnd(40,W()-40), y:rnd(-520,-30), vx:rnd(-40,40), vy:rnd(80,140)+hud.wave*6, r:20, hp:3, ang:rnd(-2,2)});
    }
    // boss
    if(hud.wave===5){
      enemies.push({x:W()*0.5+rnd(-60,60), y:-140, vx:0, vy:80, hp:70, ai:'straight', boss:true, fireT:0.6});
    }
  }
  spawnWave();

  // periodic powerups
  setInterval(()=>{ const type = Math.random()<0.4?'shield':(Math.random()<0.65?'rapid':'spread');
    powerups.push({x:rnd(40,W()-40), y:-20, vy:160, type}); }, 8500);

  // ---------- Drawing ----------
  function drawShip(x,y,rot=0){
    ctx.save(); ctx.translate(x,y); ctx.rotate(rot);
    ctx.fillStyle='#c7d4ff';
    ctx.beginPath(); ctx.moveTo(0,-18); ctx.lineTo(18,4); ctx.lineTo(6,18); ctx.lineTo(-6,18); ctx.lineTo(-18,4); ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#21d0ff'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,14,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  function drawEnemy(e){
    ctx.save(); ctx.translate(e.x,e.y);
    if(e.boss){ ctx.fillStyle='#ff3b3b'; ctx.beginPath(); ctx.arc(0,0,42,0,Math.PI*2); ctx.fill(); ctx.lineWidth=7; ctx.strokeStyle='#6b0d0d'; ctx.beginPath(); ctx.arc(0,0,40,0,Math.PI*2); ctx.stroke();
    } else if(e.ai==='sine'){ ctx.fillStyle='#ffc971'; ctx.beginPath(); ctx.moveTo(0,-18); ctx.lineTo(18,0); ctx.lineTo(0,18); ctx.lineTo(-18,0); ctx.closePath(); ctx.fill();
      ctx.strokeStyle='#ad6b1a'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,14,0,Math.PI*2); ctx.stroke();
    } else if(e.ai==='straight'){ ctx.fillStyle='#d3a1ff'; roundRect(-22,-14,44,28,10); ctx.fill(); ctx.lineWidth=3; ctx.strokeStyle='#6a39a3'; roundRect(-22,-14,44,28,10); ctx.stroke();
    } else { ctx.fillStyle='#ff6b6b'; ctx.beginPath(); ctx.moveTo(0,-18); ctx.lineTo(18,0); ctx.lineTo(0,18); ctx.lineTo(-18,0); ctx.closePath(); ctx.fill();
      ctx.strokeStyle='#891b1b'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,16,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  }
  function drawRock(r){
    ctx.save(); ctx.translate(r.x,r.y); ctx.rotate(r.ang || 0);
    ctx.fillStyle='#8f8f9c'; ctx.beginPath(); ctx.arc(0,0,r.r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#51515c'; ctx.lineWidth=2; for(let i=0;i<5;i++){ ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(rnd(-r.r,r.r), rnd(-r.r,r.r)); ctx.stroke(); }
    ctx.restore();
  }
  function drawBullet(b){ ctx.save(); ctx.translate(b.x,b.y); ctx.fillStyle=b.enemy?'#ff7a7a':'#fff2a6'; roundRect(-3,-9,6,18,3); ctx.fill(); ctx.restore(); }
  function drawSpark(s){ ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(159,232,255,0.9)'; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); ctx.globalCompositeOperation='source-over'; }

  function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); }

  // ---------- Explosions ----------
  function explode(x,y,big=false){
    for(let i=0;i<(big?36:24);i++){
      sparks.push({x,y, vx:rnd(-380,380)/60, vy:rnd(-380,380)/60+2, r:rnd(big?2.2:1.2, big?3.4:2.0), life:rnd(0.42,0.92), t:0});
    }
    sfxBoom(big);
    // micro slow-mo
    if(big){ timeScale = 0.45; setTimeout(()=>{ timeScale = 1; }, 180); }
  }

  // ---------- Combat ----------
  function fireBullet(){
    const spread = hud.spreadT>0;
    const mk = (dx,dy,vx)=> bullets.push({x:player.x+dx, y:player.y-20+dy, vx:vx||0, vy:-780/60});
    if(spread){ mk(0,0,0); mk(-10,2,-180/60); mk(10,2,180/60); } else { mk(0,0,0); }
    sfxLaser();
  }
  function fireEnemyBullet(x,y,speed){ enemyBullets.push({x,y, vx:0, vy:speed}); }

  // ---------- Overlay ----------
  const overlay = document.getElementById('overlay'), ovTitle=document.getElementById('ovTitle'),
        ovWave=document.getElementById('ovWave'), ovScore=document.getElementById('ovScore');
  document.getElementById('retryBtn').onclick = ()=> resetGame();
  function gameOver(victory=false){
    running=false;
    ovTitle.textContent = victory ? 'Victory!' : 'Game Over';
    ovWave.textContent = hud.wave;
    ovScore.textContent = hud.score;
    overlay.style.display='flex';
  }
  function resetGame(){
    overlay.style.display='none';
    bullets.length=0; enemies.length=0; rocks.length=0; enemyBullets.length=0; sparks.length=0; powerups.length=0;
    hud.score=0; hud.wave=1; hud.lives=3; hud.power='—'; hud.rapidT=0; hud.spreadT=0; hud.shieldT=0; setHud();
    player.x=W()*0.5; player.y=H()*0.78; player.vx=player.vy=0; player.alive=true;
    spawnWave();
    running=true;
    tPrev=performance.now(); rafId=requestAnimationFrame(loop);
  }

  // ---------- Main loop ----------
  function loop(ts){
    const dt = Math.min(0.032, (ts - tPrev)/1000) * timeScale; tPrev = ts;
    // background (parallax)
    ctx.fillStyle='#0b0f1a'; ctx.fillRect(0,0,W(),H());
    // starfield
    ctx.save();
    const px1 = (ts*0.03)%W(), px2 = (ts*0.06)%W();
    ctx.fillStyle='rgba(135,164,255,0.35)'; for(let i=0;i<120;i++){ ctx.fillRect((i*83+px1)%W(), (i*37)%H(), 2,2); }
    ctx.fillStyle='rgba(159,184,255,0.85)'; for(let i=0;i<200;i++){ ctx.fillRect((i*47+px2)%W(), (i*59)%H(), 2,2); }
    ctx.restore();

    // Player movement
    if(player.alive){
      let vx=0, vy=0;
      if(key.left) vx-=1; if(key.right) vx+=1; if(key.up) vy-=1; if(key.down) vy+=1;
      if(mobile && touchMove){ /* already applied in move handler */ } else {
        if(vx||vy){ const m=Math.hypot(vx,vy); vx/=m; vy/=m; }
        player.vx += vx*player.speed*dt;
        player.vy += vy*player.speed*dt;
        // damping
        player.vx *= 0.90; player.vy *= 0.90;
        player.x += player.vx*dt; player.y += player.vy*dt;
        clampPlayer();
      }
      // auto fire
      autofire -= dt;
      const firing = key.space || touchFire || true;
      const cadence = (hud.rapidT>0) ? 0.06 : 0.11;
      if(firing && autofire<=0){ fireBullet(); autofire = cadence; }
    }

    // Bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i]; b.x += (b.vx||0)*dt*60; b.y += b.vy*dt*60;
      drawBullet(b);
      if(b.y < -30) bullets.splice(i,1);
    }

    // Enemy bullets
    for(let i=enemyBullets.length-1;i>=0;i--){
      const b=enemyBullets[i]; b.y += b.vy*dt*60; drawBullet(b);
      if(b.y > H()+30) enemyBullets.splice(i,1);
    }

    // Enemies
    let bossAlive=false;
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      if(e.ai==='zig'){ e.x += Math.sin(ts*0.002 + e.y*0.02) * 28 * (e.tilt||1) * dt*60; }
      if(e.ai==='sine'){ e.x += Math.sin(ts*0.004 + (e.phase||0)) * (e.amp||60) * dt; }
      e.y += e.vy*dt;
      // fire
      e.fireT -= dt;
      if(e.fireT<=0){
        e.fireT = e.boss ? 0.45 : (0.9 + Math.random()*1.0);
        fireEnemyBullet(e.x + rnd(-5,5), e.y+12, e.boss? 6 : (4 + hud.wave*0.3));
      }
      drawEnemy(e);
      // offscreen recycle / keep boss in play
      if(e.y > H()+80){
        if(e.boss){ e.y = -140; }
        else { e.y = rnd(-420,-40); e.x = rnd(40,W()-40); }
      }
      // collision: player
      if(player.alive && distHit(player.x,player.y, e.x,e.y, e.boss?40:18)){
        if(hud.shieldT>0){ hud.shieldT=0; addScore(30); } else { hitPlayer(); }
        enemies.splice(i,1); explode(e.x,e.y,e.boss); continue;
      }
      // bullets vs enemy
      for(let j=bullets.length-1;j>=0;j--){
        const b=bullets[j];
        if(distHit(b.x,b.y, e.x,e.y, e.boss?38:16)){
          bullets.splice(j,1);
          e.hp -= 1;
          if(e.hp<=0){ explode(e.x,e.y,!!e.boss); addScore(e.boss?320:22); if(e.boss){ bossAlive=true; enemies.splice(i,1); gameOver(true); } else { enemies.splice(i,1); } break; }
        }
      }
      if(e.boss) bossAlive=true;
    }

    // Rocks
    for(let i=rocks.length-1;i>=0;i--){
      const r=rocks[i]; r.x += r.vx*dt; r.y += r.vy*dt; r.ang += 0.03;
      drawRock(r);
      if(r.y>H()+60){ r.y=rnd(-420,-40); r.x=rnd(40,W()-40); }
      // player hit
      if(player.alive && distHit(player.x,player.y,r.x,r.y,r.r)){
        if(hud.shieldT>0){ hud.shieldT=0; addScore(20); } else { hitPlayer(); }
        rocks.splice(i,1); explode(r.x,r.y,false);
      }
      // bullet hit
      for(let j=bullets.length-1;j>=0;j--){
        const b=bullets[j];
        if(distHit(b.x,b.y,r.x,r.y,r.r)){
          bullets.splice(j,1); r.hp -= 1;
          if(r.hp<=0){ explode(r.x,r.y,false); addScore(12); rocks.splice(i,1); } else { /* flash omitted for perf */ }
          break;
        }
      }
    }

    // Powerups
    for(let i=powerups.length-1;i>=0;i--){
      const p=powerups[i]; p.y += p.vy*dt;
      // draw
      ctx.save(); ctx.translate(p.x,p.y);
      ctx.strokeStyle = p.type==='shield' ? '#66e1ff' : (p.type==='rapid' ? '#fff2a6' : '#9ae6b4');
      ctx.lineWidth=4; ctx.beginPath(); ctx.arc(0,0,16,0,Math.PI*2); ctx.stroke(); ctx.restore();
      if(p.y>H()+40){ powerups.splice(i,1); continue; }
      if(player.alive && distHit(player.x,player.y,p.x,p.y,22)){
        if(p.type==='shield'){ hud.shieldT=6; hud.power='Shield'; }
        if(p.type==='rapid'){ hud.rapidT=7; hud.power='Rapid'; }
        if(p.type==='spread'){ hud.spreadT=7; hud.power='Spread'; }
        setHud(); addScore(40); powerups.splice(i,1);
      }
    }

    // Enemy bullets hit player
    for(let i=enemyBullets.length-1;i>=0;i--){
      const b=enemyBullets[i];
      if(player.alive && distHit(player.x,player.y,b.x,b.y,16)){
        enemyBullets.splice(i,1);
        if(hud.shieldT>0){ hud.shieldT=0; addScore(10); } else { hitPlayer(); }
      }
    }

    // Sparks
    for(let i=sparks.length-1;i>=0;i--){
      const s=sparks[i]; s.t += dt; s.x += s.vx; s.y += s.vy; s.vy += 0.12; s.r *= 0.98;
      drawSpark(s); if(s.t > s.life) sparks.splice(i,1);
    }

    // Timers
    if(hud.shieldT>0){ hud.shieldT -= dt; if(hud.shieldT<=0){ hud.shieldT=0; hud.power = (hud.rapidT>0?'Rapid':(hud.spreadT>0?'Spread':'—')); setHud(); } }
    if(hud.rapidT>0){ hud.rapidT -= dt; if(hud.rapidT<=0){ hud.rapidT=0; hud.power = (hud.spreadT>0?'Spread':(hud.shieldT>0?'Shield':'—')); setHud(); } }
    if(hud.spreadT>0){ hud.spreadT -= dt; if(hud.spreadT<=0){ hud.spreadT=0; hud.power = (hud.rapidT>0?'Rapid':(hud.shieldT>0?'Shield':'—')); setHud(); } }

    // Wave progression
    const enemiesLeft = enemies.length;
    const bossAliveNow = enemies.some(e=>e.boss);
    if(!bossAliveNow && enemiesLeft===0 && rocks.length<2){
      if(hud.wave < 5){ hud.wave++; setHud(); spawnWave(); addScore(90); }
    }

    if(running){ rafId=requestAnimationFrame(loop); }
  }
  function distHit(x1,y1,x2,y2,r){ const dx=x1-x2, dy=y1-y2; return dx*dx+dy*dy <= r*r; }

  function hitPlayer(){
    if(!player.alive) return;
    hud.lives--; setHud();
    explode(player.x,player.y,true);
    if(hud.lives>0){
      player.x=W()*0.5; player.y=H()*0.78; player.vx=player.vy=0; hud.shieldT=2.4; // mercy
    } else {
      player.alive=false; running=false;
      document.getElementById('ovTitle').textContent='Game Over';
      document.getElementById('ovWave').textContent=hud.wave;
      document.getElementById('ovScore').textContent=hud.score;
      document.getElementById('overlay').style.display='flex';
    }
  }

  // Kick off
  try{
    tPrev=performance.now(); rafId=requestAnimationFrame(loop);
  }catch(e){ showErr('Boot failure: '+(e.message||e)); }

})();
</script>
</body>
</html>
